# put useful commands here
export MARKPATH=$HOME/.marks

function jump {
    cd -P "$MARKPATH/$1" 2>/dev/null || echo "No such mark: $1"
}


function mark {
    mkdir -p "$MARKPATH"; ln -s "$(pwd)" "$MARKPATH/$1"
}

function unmark {
    rm -i "$MARKPATH/$1"
}

function marks {
    ls -l "$MARKPATH" | sed 's/  / /g' | cut -d' ' -f9- | sed 's/ -/\t-/g' && echo
}


_completemarks() {
    # COMP_WORDS: 命令行中的所有输入单词
    # COMP_CWORD: 光标下输入单词的索引
    local curw=${COMP_WORDS[COMP_CWORD]}
    local wordlist=$(find $MARKPATH -type l -printf "%f\n" 2> /dev/null )

    # compgen -W: 返回以$curw为前缀的words
    # COMPREPLY: 候选的补全结果
    # COMP_WORDBREAKS: 类型为字符串，表示单词之间的分隔符
    # COMP_LINE: 类型为字符串，表示当前的命令行输入
    COMPREPLY=($(compgen -W '${wordlist[@]}' -- "$curw"))
    return 0
}
 
# jump unmark 使用_completemarks函数来补全
complete -F _completemarks j jump unmark

extract() {
    if [ -f "$1" ]; then
        outputDir=$(pwd)
        if [ -d "$2" ]; then
            outputDir="$2"
        else
            echo "The output directory doesn't exist, use the current working directory instead."
        fi

        # 在case语句里，双分号;;类似于break语句，还有特殊的符号： ;&及;;&
        case "$1" in
            # 也可以使用 =~ 来测试正则表达式，不过这个更简单
            *.tar.gz | *.tgz )  tar -zxf "$1" -C $outputDir        ;;
            *.tar.bz2| *.tbz2)  tar -jxf "$1" -C $outputDir        ;;
            *.tar)      tar -xf "$1" -C $outputDir                 ;;
            *.bz2)      (cd $outputDir; bunzip2 "$1";)             ;;
            *.gz)       (cd $outputDir; gunzip "$1";)              ;;
            *.zip)      unzip "$1" -d $outputDir                   ;;
            *.ZIP)      unzip "$1" -d $outputDir                   ;;
            *.Z)        (cd $outputDir; uncompress.real "$1";)     ;;
            #*.pax)      cat "$1" | pax -r                       ;;
            #*.pax.Z)    uncompress "$1" --stdout | pax -r       ;;
            #*.dmg)      hdiutil mount "$1"                      ;;
            *) echo "'$1' cannot be extracted/mounted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file to extract"
    fi
}


# put you aliase here
# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias c='cat'

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'


alias j='jump'
alias e='extract'
alias rm='rm -i'
alias py='python'
alias ..='cd ..'

type ipython > /dev/null 2>&1 && alias py='ipython'
type vim > /dev/null 2>&1 && alias v='vim'



function getAliasWordsLength () {
    local content=$(alias "$1")
    eval content=${content#*=}
    echo $content
}

# function used to wrap completion function for alias
function makeCompletionWrapper () {
	local actualCommand="$1"
	local actualCompFunc="$2"
    local aliasCommand="$3"
	local aliasCompFunc="$4"

    local aliasContent=$(getAliasWordsLength $aliasCommand)
    local aliasWordsArray=( $(getAliasWordsLength $aliasCommand) )
    local aliasWordsArrayLength=${#aliasWordsArray[@]}
	local function="
function $aliasCompFunc {
    ((COMP_CWORD=$aliasWordsArrayLength))

    # remove the alias
    currentWords=\${COMP_WORDS[@]:1}
    COMP_WORDS=( "${aliasWordsArray[@]}" \${currentWords:-' '} )
    COMP_LINE=\${COMP_LINE/\"\$1\"/\""${aliasContent}"\"}
    ((COMP_POINT += ${#aliasContent} - \${#1}))

    # load the completion function for actual command
    _completion_loader "$actualCommand"
    "$actualCompFunc"
    return 0
}"
	eval "$function"
}


# usage of makeCompletionWrapper function
alias get='sudo apt-get install'
makeCompletionWrapper sudo _sudo get _get
complete -F _get get

alias drop='sudo apt-get remove'
makeCompletionWrapper sudo _sudo drop _drop
complete -F _drop drop
